# -*- coding: utf-8 -*-
"""PythonClass1 : Arrays

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Mz96RnDUVqf_0kLQTPNrnlj44Xu3LnT
"""

#Import array with ten num and find average

from array import *  
#Signed integer 2 bytes
number_list = array('i', [15,25,35,40,50,60,70,80,90,100])

from statistics import mean
#number_list = [45, 34, 10, 36, 12, 6, 80]
avg = mean(number_list)
print("The average is ", round(avg,2))

#Finding max n min element
import numpy as my
bar = my.array([1, 3.14159, 1100, -2.71828])
print(bar.max())
print(bar.min())
#Finding average mean in python
import statistics
statistics.mean(bar)

num = int(input("How many number?"))
for n in range(var):
  total_sum += n
  avg = total_sum/num
  print("Average is ", avg)

arr =[1,2,3,4,5]
max = arr[0]
n = len(arr)

for i in range (1,n):
 if arr[i] > max:
  max = arr[i]
 print(max)

 #print every number that is great than the number store in [0] location which is 1

#adding to the middle 
from array import *
array1 = array('i', [10,20,30,40,50])
array1.insert(1,60)  #(1,60) add 60 before index 1
for x in array1:
  print(x)

#How to remove an element in array by index
from array import *
array2 = array('i', [10,20,30,40,50])
array2.pop(2)
for x in array2:
  print(x)

#How to find an index of a given value
from array import *
array1 = array('i', [10,20,30,40,50])
print("40 index : " +(str)(array1.index(40)))
array1[2] = 80
array1[array1.index(40)] = 35
for i in array1:
  print(i)

#How to edit value in array
from array import *
array1 = array('i', [10,20,30,40,50])
array1[2] = 80
for x in array1:print(x)

#How to remove a specific value in array
from array import *
array1 = array('i', [10,20,30,40,50,99])
array1.remove(99)
for x in array1:
  print(x)

#print each element in array A
from array import*
A = array('i', [10,20,30,40,50])
for x in A:
  print(x)
  print("The third element i array A is " + (str)(A[2]))
# sum1 = A[2]+A[3]
# print(sum1)
# sum2 = str(A[2]) + " " + str(A[3])
# print(sum2)

#basic how to find average in array
from array import*
A = array('i', [10,20,30,40,50])

sum = A[0] + A[1]
sum += A[2] + A[3] 
sum += A[4] 
print(sum)
size = int(input("Enter the size of array"))
avg = sum/size
print(avg)
 #find index from a value in array
#print(A.index(40))

 
#Edit number in array
# A[2] = 35
# for i in A:
#   print(i)

for i in range(0,10,2): #start from zero stop before ten and increment by 2
 print(i)

from array import *
array1 = array('i', [10,20,30,40,50])
array1[2] = 80
array1[array1.index(80)]=35
for x in array1:print(x)

#Adding to the back
aList = [123, 'xyz', 'zara', 'abc']
aList.append(2014)
print (aList)

def findPeakElement(A, left, right):
 
    # find the middle element. To avoid overflow, use `left + (right - left) / 2`
    mid = (left + right) // 2
 
    # check if the middle element is greater than its neighbors
    if ((mid == 0 or A[mid - 1] <= A[mid]) and
            (mid == len(A) - 1 or A[mid + 1] <= A[mid])):
        return mid
 
    # If the left neighbor of `mid` is greater than the middle element,
    # find the peak recursively in the left sublist
    if mid - 1 >= 0 and A[mid - 1] > A[mid]:
        return findPeakElement(A, left, mid - 1)
 
    # If the right neighbor of `mid` is greater than the middle element,
    # find the peak recursively in the right sublist
    return findPeakElement(A, mid + 1, right)
 
 
if __name__ == '__main__':
 
    A = [8, 9, 10, 2, 5, 6]
 
    index = findPeakElement(A, 0, len(A) - 1)
    print("The peak element is", A[index])

class Solution(object):
   def findPeakElement(self, nums):
      low = 0
      high = len(nums)-1
      while low<high:
         mid = low + (high - low+1)//2
         if (mid-1>=0 and nums[mid-1]<=nums[mid]):
            low = mid
         else:
            high = mid-1
      return nums[low+1]
ob1 = Solution()
print(ob1.findPeakElement([15,35,85,96,5,6,8,12]))

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

# example data with peaks:
x = np.linspace(-1,3,1000)
data = -0.1*np.cos(12*x)+ np.exp(-(1-x)**2)

#     ___ detection of local minimums and maximums ___

a = np.diff(np.sign(np.diff(data))).nonzero()[0] + 1               # local min & max
b = (np.diff(np.sign(np.diff(data))) > 0).nonzero()[0] + 1         # local min
c = (np.diff(np.sign(np.diff(data))) < 0).nonzero()[0] + 1         # local max
# +1 due to the fact that diff reduces the original index number

# plot
plt.figure(figsize=(12, 5))
plt.plot(x, data, color='grey')
plt.plot(x[b], data[b], "o", label="min", color='r')
plt.plot(x[c], data[c], "o", label="max", color='b')
plt.show()

from collections import Counter
from scipy.signal import detrend
import numpy as np
from enum import IntEnum


class Event(IntEnum):
    PEAK = 0
    VALLEY = 1


class EventState:
    def __init__(self, event, close_prices, best_price, best_idx=0):
        self.event = event
        self._close_prices = close_prices
        self.best_price = best_price
        self.best_idx = best_idx
        self._event_indices = {Event.PEAK: [], Event.VALLEY: []}

    @property
    def event_inices(self):
        return tuple(self._event_indices.values())

    def switch(self):
        """Switch event state (name)"""
        self.event ^= 1

    def set_best_rate(self, best_idx):
        self.best_price = self._close_prices[best_idx]
        self.best_idx = best_idx

    def add_best_index(self):
        self._event_indices[self.event].append(self.best_idx)


def get_peak_valley(arr, threshold, window_size, overlap, req_angles):
    # validate params
    window_size = round(window_size)
    req_angles = max(round(req_angles), 1)
    window_step = max(round(window_size * (1 - overlap)), 1)

    # get all points that classify as a peak/valley
    peak_counts, valley_counts = Counter(), Counter()
    arr_size = len(arr)

    for i in range(0, arr_size, window_step):
        flattened = detrend(arr[i:i + window_size])
        std, avg = np.std(flattened), np.mean(flattened)
        lower_b = avg - std * threshold
        upper_b = avg + std * threshold

        for idx, val in enumerate(flattened):
            if val < lower_b:
                valley_counts[idx + i] += 1
            elif val > upper_b:
                peak_counts[idx + i] += 1

    # discard points that have counts below the threshold
    pk_inds = [i for i, c in peak_counts.items() if c >= req_angles]
    vly_inds = [i for i, c in valley_counts.items() if c >= req_angles]

    # initialize iterator to find to best peak/valley for consecutive detections
    if len(pk_inds) == 0 or len(vly_inds) == 0:
        return pk_inds, vly_inds

    if pk_inds[0] < vly_inds[0]:
        curr_event, best_price = Event.PEAK, close_prices[pk_inds[0]]
    else:
        curr_event, best_price = Event.VALLEY, close_prices[vly_inds[0]]

    event_state = EventState(curr_event, close_prices=close_prices, best_price=best_price)
    event_inds = sorted(pk_inds + vly_inds)
    peak_ids_set = set(pk_inds)

    # iterate through points and only carry forward the index
    # that has the highest or lowest value from the current group
    for x in event_inds:
        in_peak = x in peak_ids_set
        is_peak = event_state.event == Event.PEAK
        is_valley = event_state.event == Event.VALLEY

        if (in_peak and is_valley) or (not in_peak and is_peak):
            event_state.add_best_index()
            event_state.switch()
            event_state.set_best_rate(best_idx=x)
            continue

        if (in_peak and is_peak and close_prices[x] > event_state.best_price) or \
                (not in_peak and is_valley and close_prices[x] < event_state.best_price):
            event_state.set_best_rate(x)

    event_state.add_best_index()

    return event_state.event_inices

from math import sin,isnan
from pylab import *

def peakdet(v, delta,thresh,x):
    delta=abs(delta)
    maxtab = []
    mintab = []

    v = asarray(v)

    mn, mx = v[0], v[0]
    mnpos, mxpos = NaN, NaN

    lookformax = True

    for i in arange(len(v)):
        this = v[i]
        if abs(this)>thresh:
            if this > mx:
                mx = this
                mxpos = x[i]
            if this < mn:
                mn = this
                mnpos = x[i]
            if lookformax:
                if (this < mx-delta):
                    if (mx>abs(thresh)) and not isnan(mxpos):
                        maxtab.append((mxpos, mx))
                    mn = this
                    mnpos = x[i]
                    lookformax = False
            else:
                if (this > mn+delta):
                    if (mn<-abs(thresh)) and not isnan(mnpos):
                        mintab.append((mnpos, mn))
                    mx = this
                    mxpos = x[i]
                    lookformax = True
    return array(maxtab), array(mintab)

#Input Signal
t=array(range(100))
series=0.3*sin(t)+0.7*cos(2*t)-0.5*sin(1.2*t)

thresh=0.95 #Threshold value
delta=0.0 #

a=zeros(len(t)) #
a[:]=thresh #

maxtab, mintab = peakdet(series,delta,thresh,t)

#Plotting output
scatter(array(maxtab)[:,0], array(maxtab)[:,1], color='red')
scatter(array(mintab)[:,0], array(mintab)[:,1], color='blue')
xlim([0,t[-1]])
title('Peak Detector')
grid(True)
plot(t,a,color='green',linestyle='--',dashes=(5,3))
plot(t,-a,color='green',linestyle='--',dashes=(5,3))
annotate('Threshold',xy=(t[-1],thresh),fontsize=9)
plot(t,series,'k')
show()

print(array(maxtab)[:,1])
print(array(mintab)[:,1])