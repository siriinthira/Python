# -*- coding: utf-8 -*-
"""hashtable.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qAYxfOGS6tktv8MM77TcDCdA2WAYVwd3

#Self Study

A Hash Table is a key value lookup

key => value lookup

For example, when you want to associate name with a set of info abou them.
A Hash table would be a perfect solution for this/
In Hash table - the key as well as the value can be any type of data structure
A String is often used, but it can be a person, a square, a person. 
Anything as long as you have a hash function.

At a high level, we want to store object in an array.
How can we jump from a String to a particular index in the array?

Code Explained!

A Hash function takes in a String and convert a String into an integer.
And then a Hash function will remap that integer into an index into that array.
That's when we can find the person we're looking for in that array.

Fact

Two different Strings can have the same Hash Code.
That's because there are an infinite number of String numbers but a finite numbers of hash codes.

In addition, since we are remapping the hash code into smaller index, two things with different hash codes could acctually wind up mapped to the same index. When this happens, we just call the "Collision". There are so many ways to resolve the collision. One of them is called "Chaining" which is the most common one and it is very simple.

When there is collision, we'll just store them in linkedlist - be an array of a LinkedList of people. (Array of a LinkedList of a value)

When you get the call - get the value "Alex" - you need to look through all the values on the linkedlist and pull out the value for Alex.

Linkedlist contains both actual person objects and the actual orginal keys.
The reason for that is...if you only store the person object you'd see all these people who mapped to this index but you wouldn't know which one they are.
So you just need to store a key with them.

When you get call - get me the value for Alex, then you will call this hash function. You'll get a hash code back.
You map over to this index and then you walk through and look for the thing with the key of Alex. So that's the basics of how the hash table is operated.


String --> Hash Code --> Index

When someone says put the value of Alex mapping to this person.
We call this hash code function then get us back the hash code.
Then we map from this hash code over to an index in the array and then we put it into the LinkedList.

à¹‡Homework

Read about Collision handling in different ways
Read about hash table grow/shrink
Implement a simple hash table
practice questions

Summary

Used to index large amount of data
Address of each key is calculated using a key itself
Collisions resolve with open adressing + linear probe or closed addressing
Hashing is widely used in database indexing, compiler, caching, password authentication and more.
Insertion , deletion and retriaval occure in constant time for the best case scenario

https://www.youtube.com/watch?v=b4b8ktEV4Bg&list=TLPQMTUxMTIwMjFvndxDYBINbg&index=2

A Hash table is a function that allows a fast retrieval of data no matter how many data there is. Hash table is widely used in database indexing,  catching, program compilations, re-checking and much more.

For a simple one dimensional array list, to find an item in a list - you can emply* a brute force approach. Searching a linear search this will involved checking each term. For a very large array, this could take a long time. O(n)
However, if you know the number of index of that element, you could retrieve the item very quickly. O(1)

# Hash Table
"""

class HashTable:
  def __init__(self):
    self.MAX = 10
    self.arr = [None for i in range(self.MAX)]
  def get_hash(self, key):
      hash = 0
      for char in key:
        hash += ord(char)
        return hash % self.MAX
  def get(self, key):
          h = self.get_hash(key)
          return self.arr[h]
  def add(self, key, val):
          h = self.get_hash(key)
          self.arr[h] = val

phone_book = HashTable()
phone_book.add('John Mayer','11111111')
phone_book.get('John Mayer')
phone_book.add('Peter Parker','22222222')
phone_book.get('Peter Parker')
phone_book.arr

"""# Implementation 2 with method overriding"""

class HashTable:
  def __init__(self):
    self.MAX = 10
    self.arr = [None for i in range(self.MAX)]
  def get_hash(self, key):
      hash = 0
      for char in key:
        hash += ord(char)
        return hash % self.MAX
  def __getitem__(self, key):
          h = self.get_hash(key)
          return self.arr[h]
  def __setitem__(self, key, val):
            h = self.get_hash(key)
            self.arr[h] = val

phone_book = HashTable()
phone_book["Iris Smith"] = '11111111'
phone_book["Siri Smith"] = '22222222'
phone_book["John Doe"] = '33333333'
phone_book["Peter Parker"] = '44444444'
phone_book["Iris Smith"]

"""# Hash Table Chaining"""

class HashTable:
  def __init__(self):
   self.MAX = 10
   self.arr = [[] for i in range(self.MAX)]

  def get_hash(self, key):
    hash = 0
    for char in key:
        hash += ord(char)
    return hash % self.MAX

  def __getitem__(self, key):
      arr_index = self.get_hash(key)
      for kv in self.arr[arr_index]:
        if kv[0] == key:
          return kv[1]
  def __setitem__(self, key, val):
      h = self.get_hash(key)
      found = False
      for idx, element in enumerate(self.arr[h]):
        if len(element)==2 and element[0] == key:
          self.arr[h][idx] = (key,val)
          found = True
      if not found:
          self.arr[h].append((key,val))
          
  def __delitem__(self, key):
        arr_index = self.get_hash(key)
        for index, kv in enumerate(self.arr[arr_index]):
          if kv[0] == key:
           print("del",index)
           del self.arr[arr_index][index]

phone_book = HashTable()
phone_book["Sali Smith"] = '11111111'
phone_book["Lisa Smith"] = '22222222'
phone_book["John Doe"] = '33333333'
phone_book["Peter Parker"] = '44444444'
phone_book["Lisa Snith"]
del phone_book["Peter Parker"]
phone_book.arr

"""# Edit"""

class HashTable:
    def __init__(self):
        self.MAX = 10
        self.arr = [[] for i in range(self.MAX)]
    def get_hash(self, key):
        hash = 0
        for char in key:
            hash += ord(char)
        return hash % self.MAX
    def __getitem__(self, key):
         arr_index = self.get_hash(key)
         for kv in self.arr[arr_index]:
             if kv[0] == key:
                 return kv[1]
    def __setitem__(self, key, val):
        h = self.get_hash(key)
        found = False
        for idx, element in enumerate(self.arr[h]):
            if len(element)==2 and element[0] == key:
                self.arr[h][idx] = (key,val)
                found = True
        if not found:
            self.arr[h].append((key,val))

    def __delitem__(self, key):
        arr_index = self.get_hash(key)
        for index, kv in enumerate(self.arr[arr_index]):
            if kv[0] == key:
                print("del",index)
                del self.arr[arr_index][index]
 

phone_book = HashTable()
phone_book["John Smith"] = '11111111'
phone_book["Lisa Smith"] = '22222222'
phone_book["John Doe"] = '33333333'
phone_book["Peter Parker"] = '44444444'
phone_book["John Doe"]
del phone_book["Peter Parker"]
phone_book.arr